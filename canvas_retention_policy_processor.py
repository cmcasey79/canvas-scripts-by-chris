################################################################################
################################################################################
## Canvas term retention policy processor                                     ##
##                                                                            ##
## Fill in the three variables directly below this header, then run with py   ##
## **Use at your own risk.  Please try changes in Test/Beta before Prod.**    ##
##                                                                            ##
## This script is designed to be run once daily at a regularly scheduled time ##
##                                                                            ##
## 2024 Christopher M. Casey (cmcasey79@hotmail.com)                          ##
################################################################################
################################################################################
script_version='2024.07.31.00202public'

# Script mode setup
# set as '' for deault operation, 'unattended' to run without prompts using the info below, 'verbose' for more detailed screen progress output, 'silent' to run without screen output, or 'silentunattended' or 'verboseunattended' to combine the options.
mode='unattended'

# Canvas API token setup
canvas_api_token='' 

# Canvas subdomain setup
# set this variable as your subdomain of instructure.com (ex: umich)
canvas_subdomain=''

# Canvas vanity domain setup
# set these variable as your relevant vanity domain(s) if you have them, otherwise, leave it as ''
canvas_production_vanity_domain=''
canvas_beta_vanity_domain=''
canvas_test_vanity_domain=''

# Canvas account id setup
# set this variable as the account/subaccount id you'd like to work in.
canvas_account_id=

# Canvas environment setup
# set this variable as production, test, beta or leave as '' to prompt if not running in unattended mode
canvas_environment=''

# Retention policy setup
# Set the time periods before deletion when notification emails will be sent to teachers.  60, 30, and 5 days are included as examples.
notification_periods=[{'years':0,'months':0,'weeks':0,'days':60},{'years':0,'months':0,'weeks':0,'days':25},{'years':0,'months':0,'weeks':0,'days':5}]
# Set the time period after which courses will be deleted
delete_period={'years':6,'months':0,'weeks':0,'days':0}

# Email server setup
email_smtpservername=''
email_secureport=465
# Use the following 3 lines to try emails with authenticated SMTP.  Must provide valid username and password when email_authrequired=True
email_authrequired=False
email_username=''
email_password=''

# Email sender setup.  This is the name and email address that notifications generated by the script will appear to come from
email_from_name=''
email_from_address=''

# Enter an email address in the following line to deliver teacher notification email content to for debugging purposes.
# Entering an address here will cause all teacher emails to be sent to this specified address instead of the actual teacher email address.
# Leave as '' for normal script operation
debug_email_to_address=''

# Enter an email address to send a log of the script actions if desired (highly recommended)
log_email_to_address=''

################################################################################
################################################################################
## No changes to below code should be necessary.                              ##
################################################################################
################################################################################

import re
import socket
import requests
import urllib3.exceptions
import io
import json
import datetime
import time
import dateutil.relativedelta
import csv
import smtplib
import collections
from email.message import EmailMessage
from email.headerregistry import Address
from email.utils import make_msgid

scriptlog=''

#Added to suppress warnings
requests.packages.urllib3.disable_warnings(category=urllib3.exceptions.InsecureRequestWarning)

#Requests call with retry on server error
def requestswithretry(retries=3, backoff_factor=0.3, status_forcelist=(500, 502, 504), session=None, ):
    session = session or requests.Session()
    retry = requests.packages.urllib3.util.retry.Retry(
        total=retries,
        read=retries,
        connect=retries,
        backoff_factor=backoff_factor,
        status_forcelist=status_forcelist,
        allowed_methods=frozenset({'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PUT', 'TRACE', 'POST'})
    )
    adapter = requests.adapters.HTTPAdapter(max_retries=retry)
    session.mount('http://', adapter)
    session.mount('https://', adapter)
    return session

# Paginated API call to Canvas
# Returns a tuple including list of all items from all pages of a paginated API call and the http status code and reason returned from the call(s)
# Last updated 2024-01-16
def canvas_get_allpages(url, headers):
    if not 'per_page=' in url:
        url=url+('&' if '?' in url else '?')+'per_page=100'
    return_data=[]
    return_key=None
    repeat=True
    while repeat:  
        canvas_request=requestswithretry().get(url,headers=headers)
        if canvas_request.status_code!=200:
            return_data=None
            repeat=False
        else:
            canvas_request_responsedata=canvas_request.json()
            # if Canvas returned a single item dictionary instead of a list, try using the value of that dictionary as the list
            if type(canvas_request_responsedata) is dict:
                if len(canvas_request_responsedata.keys())==1:
                    return_key=list(canvas_request_responsedata.keys())[0]
                    canvas_request_responsedata=next(iter(canvas_request_responsedata.values()))
                else:
                    return_data=canvas_request_responsedata
                    repeat=False
            if type(canvas_request_responsedata) is list:
                # if a list was returned, add it to the existing list
                return_data=return_data+canvas_request_responsedata
                url=canvas_request.links.get('current',{}).get('url',url)
                last_url=canvas_request.links.get('last',{}).get('url','')
                # if not on the last page of results, set up retrieval of next page
                if (url != last_url) and ('next' in canvas_request.links.keys()):
                    url=canvas_request.links['next']['url']
                else:
                    repeat=False
    return_data_namedtuple = collections.namedtuple('return_data_namedtuple', ['data', 'reason', 'status_code'])
    return return_data_namedtuple(return_data if (return_key==None) else {return_key:return_data},str(url)+': '+str(canvas_request.reason),canvas_request.status_code)

# Prompt and/or validate canvas envornment information.  Canvas_environment is a dict which will be populated by the function.
# Prompts and/or validates the working environment, domains, api token, account_id.
# Only validates the working environment by default, but an enviromnet list in the form of ['production','beta','test'] can be passed if validation of additional environments is needed.
# Returns true if everything was properly validated, false if some information could not be valitated (signaling the script should end)
# Last updated 2024-07-14.
def canvas_validate_environment(canvas_environment, validate_environments=None):
    global scriptlog
    # Validate Canvas environment selection and domains
    domain_validated=False
    while not domain_validated:
        # Prompt for Canvas environment selection
        env_selection=False
        while (not env_selection):
            if mode[-10:]=='unattended' or canvas_environment['working_environment']!='':
                env=canvas_environment['working_environment'][0]
            else:
                env=input('Which Canvas environment would you like to work in: [P]roduction, [T]est, or [B]eta? ')
            env_selection=True
            if env.lower()=='p':
                canvas_environment['working_environment']='production'
            elif env.lower()=='t':
                canvas_environment['working_environment']='test'
            elif env.lower()=='b':
                canvas_environment['working_environment']='beta'
            else:
                if mode[-10:]=='unattended':
                    print('Invalid canvas_environment selection.')
                else:
                    print('Invalid selection, please try again.')
                    env_selection=False
                canvas_environment['working_environment']=''
        if validate_environments==None:
            validate_environments=[canvas_environment['working_environment']]
        if canvas_environment['subdomain']=='' and mode[-10:]!='unattended':
            canvas_environment['subdomain']=input('Please enter your instructure.com subdomain (ex: umich): ')
        for environment in validate_environments:
            if canvas_environment['domains'][environment]=='':
                if mode[-10:]!='unattended':
                    canvas_environment['domains'][environment]=input('Please enter your '+environment+' Canvas vanity domain (hit enter/return if you do not have one): ')
                if canvas_environment['domains'][environment]=='':
                    canvas_environment['domains'][environment]=canvas_environment['subdomain']+('.'+environment if (environment!='' and environment!='production') else '')+'.instructure.com'
        domain_validated=True
        for environment in validate_environments:
            environment_validated=False
            url='https://'+canvas_environment['domains'][environment]
            if mode[0:6]!='silent': print(url)
            try:
                r = requests.get(url)
            except requests.exceptions.RequestException as e:
                print(datetime.datetime.now().isoformat()+': Connection error '+str(e))
                scriptlog+=datetime.datetime.now().isoformat()+': Connection error '+str(e)+'\n'
            else:
                if r.status_code==200:
                    if mode[0:6]!='silent': print(datetime.datetime.now().isoformat()+': Connection test to '+canvas_environment['domains'][environment]+' successful, proceeding...')
                    if mode[-10:]=='unattended': scriptlog+=datetime.datetime.now().isoformat()+': Connection test to '+canvas_environment['domains'][environment]+' successful, proceeding...\n'
                    environment_validated=True
                elif r.status_code==401:       
                    if mode[0:6]!='silent': print(datetime.datetime.now().isoformat()+': Connection test to '+canvas_environment['domains'][environment]+' successful but not validated, vanity domain or authentication may be needed, proceeding...')
                    if mode[-10:]=='unattended': scriptlog+=datetime.datetime.now().isoformat()+': Connection test to '+canvas_environment['domains'][environment]+' successful but not validated, vanity domain or authentication may be needed, proceeding...\n'
                    environment_validated=True
                else:
                    print(datetime.datetime.now().isoformat()+': Error '+str(r.status_code)+' - connection to '+canvas_environment['domains'][environment]+' failed.')
                    if mode[-10:]=='unattended': scriptlog+=datetime.datetime.now().isoformat()+': Error '+str(r.status_code)+' - connection to '+canvas_environment['domains'][environment]+' failed.\n'
            if not environment_validated:
                if canvas_environment['domains'][environment].split('.')[0]==canvas_environment['subdomain']:
                    canvas_environment['subdomain']=''
                canvas_environment['domains'][environment]=''
            domain_validated=domain_validated and environment_validated
        domain_validated=domain_validated or mode[-10:]=='unattended'
    # Validate API Token
    apitoken_validated=False
    while (not apitoken_validated) and (canvas_environment['domains'][environment]!=''):
        # Prompt for API Token if not given
        if canvas_environment['api_token']=='' and mode[-10:]!='unattended':
            canvas_environment['api_token']=str(input('Please enter your Canvas administrative API token: '))
        #Set HTTP headers for API calls
        url='https://'+canvas_environment['domains'][canvas_environment['working_environment']]+'/api/v1/accounts'
        r = requests.get(url,headers={'Authorization' : 'Bearer '+canvas_environment['api_token']})
        if r.status_code==200:
            canvas_account=r.json()
            if mode[0:6]!='silent': print(datetime.datetime.now().isoformat()+': API token validated, proceeding...')
            if mode[-10:]=='unattended': scriptlog+=datetime.datetime.now().isoformat()+': API token validated, proceeding...\n'
            apitoken_validated=True
            canvas_environment['account_ids']['root']=canvas_account[0]['id'] if canvas_account[0]['root_account_id']==None else canvas_account[0]['root_account_id']
            canvas_environment['url_headers']={'Authorization' : 'Bearer '+canvas_environment['api_token']}
        else:
            print(datetime.datetime.now().isoformat()+': API token validation failed.  Token or domain settings are incorrect.')
            if mode[-10:]=='unattended': scriptlog+=datetime.datetime.now().isoformat()+': API token validation failed.  Token or domain settings are incorrect.\n'
            canvas_environment['api_token']=''
            canvas_environment['url_headers']=''
            if mode[-10:]=='unattended': apitoken_validated=True
    # Prompt for Canvas Account ID
    # Get account list from Canvas
    account_id_validated=False
    canvas_accounts_dict={}
    if canvas_environment['domains'][canvas_environment['working_environment']]!='':
        all_accounts_ids_validated=True
        for account in canvas_environment['account_ids'].keys():
            account_id_validated=False
            while (not account_id_validated and all_accounts_ids_validated):
                if account=='root':
                    account_id_validated=True
                else:
                    if canvas_environment['account_ids'][account]=='' and mode[-10:]=='unattended':
                        canvas_environment['account_ids'][account]=canvas_environment['account_ids']['root']
                        account_id_validated=True
                    else:
                        if canvas_accounts_dict=={}:
                            # Get account list from Canvas if not populated yet
                            url='https://'+canvas_environment['domains'][canvas_environment['working_environment']]+'/api/v1/accounts'
                            canvas_accounts=canvas_get_allpages(url,canvas_environment['url_headers'])
                            if canvas_accounts.status_code==200:
                                for canvas_account in canvas_accounts.data:
                                    canvas_accounts_dict[canvas_account['name']]=str(canvas_account['id'])
                                    url='https://'+canvas_environment['domains'][canvas_environment['working_environment']]+'/api/v1/accounts/'+str(canvas_account['id'])+'/sub_accounts?recursive=true'
                                    canvas_subaccounts=canvas_get_allpages(url,canvas_environment['url_headers'])
                                    if canvas_subaccounts.status_code==200:
                                        for canvas_subaccount in canvas_subaccounts.data:
                                            canvas_accounts_dict[canvas_subaccount['name']]=str(canvas_subaccount['id'])
                        # Prompt for ID selection
                        if canvas_environment['account_ids'][account]=='' and mode[-10:]!='unattended':
                            canvas_environment['account_ids'][account]=input('What is the id number for the '+account+' account: # or [L]ist)? ')
                        if canvas_environment['account_ids'][account]=='L' or canvas_environment['account_ids'][account]=='l':
                            for item in canvas_accounts_dict:
                                print(canvas_accounts_dict[item]+': '+item)
                            canvas_environment['account_ids'][account]=input('What is the id number for the '+account+' account? ')
                        if str(canvas_environment['account_ids'][account]) in canvas_accounts_dict.values():
                            if mode[0:6]!='silent': print(datetime.datetime.now().isoformat()+': '+account+' account selection validated, proceeding...')
                            canvas_environment['account_ids'][account]=int(canvas_environment['account_ids'][account])
                            account_id_validated=True
                        else:
                            print(datetime.datetime.now().isoformat()+': invalid '+account+' account selection, please try again.')
                            canvas_environment['account_ids'][account]=''
                            if mode[-10:]=='unattended':
                                account_id_validated=True
            if canvas_environment['account_ids'][account]=='':
                all_accounts_ids_validated=False
    if canvas_environment['domains'][canvas_environment['working_environment']]!='':
        url='https://'+canvas_environment['domains'][canvas_environment['working_environment']]+'/api/v1/users/self'
        r=requestswithretry().get(url,headers=canvas_environment['url_headers'])
        if r.status_code==200:
            canvas_user=r.json()
            if mode[0:6]!='silent': print('Running script as '+str(canvas_user['name'])+'\n  login_id: '+str(canvas_user['login_id'])+'\n  sis_user_id: '+str(canvas_user['sis_user_id'])+'\n  email: '+str(canvas_user['email']))
            scriptlog+='Running script as '+str(canvas_user['name'])+'\n  login_id: '+str(canvas_user['login_id'])+'\n  sis_user_id: '+str(canvas_user['sis_user_id'])+'\n  email: '+str(canvas_user['email']+'\n\n')
        else:
            print(datetime.datetime.now().isoformat()+': Could not retrieve script user infomration.')
            if mode[-10:]=='unattended': scriptlog+=datetime.datetime.now().isoformat()+': Could not retrieve script user infomration..\n'
    return (canvas_environment['working_environment']!='') and (canvas_environment['domains'][canvas_environment['working_environment']]!='') and (canvas_environment['subdomain']!='') and (canvas_environment['api_token']!='') and all_accounts_ids_validated and domain_validated;

# Get an enrollment provisioning report from the specified environment and environment and term
# Returns a tuple including enrollments (if successful) and the http status code and reason returned from the first report generation api call
# Last updated 2024-07-22.
def get_canvas_enrollment_provisioning_report(canvas_environment, canvas_account_id, term_id):
    canvas_enrollments_dict={}
    url='https://'+canvas_environment['domains'][canvas_environment['working_environment']]+'/api/v1/accounts/'+str(canvas_account_id)+'/reports/provisioning_csv'
    enrollment_report_request=requests.post(url,headers=canvas_environment['url_headers'],data={'parameters[enrollment_term_id]':term_id,'parameters[enrollments]':True,'parameters[include_deleted]':True,'parameters[enrollment_states]':'active,inactive'})
    if enrollment_report_request.status_code==200:
        enrollment_report_status_response=enrollment_report_request.json()
        url=url+'/'+str(enrollment_report_status_response['id'])
        while not (enrollment_report_status_response['status']=='complete' or enrollment_report_status_response['status']=='error'):
            time.sleep(5)
            enrollment_report_status_request=requestswithretry().get(url,headers=canvas_environment['url_headers'])
            enrollment_report_status_response=enrollment_report_status_request.json()
        # once report is generated, read it into dictionary
        if enrollment_report_status_response['status']=='complete':
            url=enrollment_report_status_response['attachment']['url']
            enrollment_report_data=requestswithretry().get(url)
            canvasenrollments_csv=io.StringIO(enrollment_report_data.text)
            canvasenrollments_reader=csv.DictReader(canvasenrollments_csv)
            for row in canvasenrollments_reader:
                if int(row['canvas_course_id']) not in canvas_enrollments_dict: canvas_enrollments_dict[int(row['canvas_course_id'])]={}
                if row['base_role_type'] not in canvas_enrollments_dict[int(row['canvas_course_id'])]: canvas_enrollments_dict[int(row['canvas_course_id'])][row['base_role_type']]={}
                if row['role'] not in canvas_enrollments_dict[int(row['canvas_course_id'])][row['base_role_type']]: canvas_enrollments_dict[int(row['canvas_course_id'])][row['base_role_type']][row['role']]=[]
                canvas_enrollments_dict[int(row['canvas_course_id'])][row['base_role_type']][row['role']].append({'user_sis_id':row['user_id'],'user_id':int(row['canvas_user_id']),'enrollment_id':int(row['canvas_enrollment_id']),'status':row['status'],'section_id':int(row['canvas_section_id']),'section_sis_id':row['section_id']})
    return_data_namedtuple = collections.namedtuple('return_data_namedtuple', ['data', 'reason', 'status_code'])
    return return_data_namedtuple(canvas_enrollments_dict if enrollment_report_request.status_code==200 else None,str(url)+': '+str(enrollment_report_request.reason),enrollment_report_request.status_code)

def main():
    global scriptlog, canvas_api_token, canvas_subdomain, canvas_environment, canvas_production_vanity_domain, canvas_test_vanity_domain, canvas_beta_vanity_domain, canvas_account_id, notification_periods, delete_period, email_smtpservername, email_secureport, email_authrequired, email_username, email_password, email_from_name, email_from_address, debug_email_to_address, log_email_to_address
    hostname=socket.gethostname()
    IPAddr=socket.gethostbyname(hostname)
    print('Running script version '+script_version+' on '+hostname+', '+IPAddr)
    scriptlog+='Running script version '+script_version+' on '+hostname+', '+IPAddr+'\n'
    start_time = datetime.datetime.now()

    canvas_environment = {'api_token':str(canvas_api_token), 'url_headers':{'Authorization' : 'Bearer '+str(canvas_api_token)},'subdomain':str(canvas_subdomain), 'working_environment':canvas_environment, 'domains':{'production':canvas_production_vanity_domain, 'test':canvas_test_vanity_domain, 'beta':canvas_beta_vanity_domain}, 'account_ids':{'root':'', 'working':canvas_account_id}}
    if (not canvas_validate_environment(canvas_environment)):
        print('Canvas environment validation failed.  Exiting Script.')
        scriptlog+='Canvas environment validation failed.  Exiting Script.\n'
    else:
        start_time = datetime.datetime.now()
        # Set up retention policy notification times and variables here
        # Initialize notification period delta dictionary.
        retention_notification_periods=[]
        for notification_period in notification_periods:
            retention_notification_periods.append({'activated':False,'input':notification_period,'dict':{'years':dateutil.relativedelta.relativedelta(**notification_period).years,'months':dateutil.relativedelta.relativedelta(**notification_period).months,'days':dateutil.relativedelta.relativedelta(**notification_period).days},'delta':dateutil.relativedelta.relativedelta(**notification_period),'size':dateutil.relativedelta.relativedelta(**notification_period).years*12*31+dateutil.relativedelta.relativedelta(**notification_period).months*12+dateutil.relativedelta.relativedelta(**notification_period).days,'string':', '.join(filter(None,[((str(dateutil.relativedelta.relativedelta(**notification_period).years)+' year') if dateutil.relativedelta.relativedelta(**notification_period).years>0 else '')+('s' if dateutil.relativedelta.relativedelta(**notification_period).years>1 else ''),((str(dateutil.relativedelta.relativedelta(**notification_period).months)+' month') if dateutil.relativedelta.relativedelta(**notification_period).months>0 else '')+('s' if dateutil.relativedelta.relativedelta(**notification_period).months>1 else ''),((str(dateutil.relativedelta.relativedelta(**notification_period).days)+' day') if dateutil.relativedelta.relativedelta(**notification_period).days>0 else '')+('s' if dateutil.relativedelta.relativedelta(**notification_period).days>1 else '')]))})
        retention_notification_periods=sorted(retention_notification_periods, key=lambda d: d['size'], reverse=True)
        # Initialize empty notification dictionary
        retention_notification_data={}
        # Initialize deletion period delta
        retention_deletion_period={'data':{},'activated':False,'input':delete_period,'dict':{'years':dateutil.relativedelta.relativedelta(**delete_period).years,'months':dateutil.relativedelta.relativedelta(**delete_period).months,'days':dateutil.relativedelta.relativedelta(**delete_period).days},'delta':dateutil.relativedelta.relativedelta(**delete_period),'size':dateutil.relativedelta.relativedelta(**delete_period).years*12*31+dateutil.relativedelta.relativedelta(**delete_period).months*12+dateutil.relativedelta.relativedelta(**delete_period).days,'string':', '.join(filter(None,[((str(dateutil.relativedelta.relativedelta(**delete_period).years)+' year') if abs(dateutil.relativedelta.relativedelta(**delete_period).years)>0 else '')+('s' if abs(dateutil.relativedelta.relativedelta(**delete_period).years)>1 else ''),((str(dateutil.relativedelta.relativedelta(**delete_period).months)+' month') if abs(dateutil.relativedelta.relativedelta(**delete_period).months)>0 else '')+('s' if abs(dateutil.relativedelta.relativedelta(**delete_period).months)>1 else ''),((str(dateutil.relativedelta.relativedelta(**delete_period).days)+' day') if abs(dateutil.relativedelta.relativedelta(**delete_period).days)>0 else '')+('s' if abs(dateutil.relativedelta.relativedelta(**delete_period).days)>1 else '')]))}
        # Get term list from Canvas
        url='https://'+canvas_environment['domains'][canvas_environment['working_environment']]+'/api/v1/accounts/'+str(canvas_environment['account_ids']['root'])+'/terms'
        canvas_term_list=canvas_get_allpages(url,canvas_environment['url_headers'])
        if canvas_term_list.status_code!=200:
            print(datetime.datetime.now().isoformat()+': Error '+str(canvas_term_list.status_code)+' while retrieving term list from '+url)
            scriptlog+=datetime.datetime.now().isoformat()+': Error '+str(canvas_term_list.status_code)+' while retrieving term list from '+url+'\n'
        else:
            # Iterate through terms
            if mode[0:6]!='silent': print('\nProcessing retention policy by term...')
            scriptlog+='\nProcessing retention policy by term...'
            for term in canvas_term_list.data['enrollment_terms']:
                if mode[0:6]!='silent': print('  '+term['name']+':')
                scriptlog+='\n  '+term['name']+':\n'
                # Generate data for retention policy email notification processing
                # Generate data for each defined notification period
                for retention_notification_index, retention_notification_period in enumerate(retention_notification_periods):
                    # Work only with terms that have an end date, and where that end date is exactly the the deletion period+notification_period days ago
                    if term['end_at']!=None and ((datetime.datetime.fromisoformat(term['end_at'].replace('Z','+00:00')).date()+retention_deletion_period['delta']-retention_notification_period['delta']-datetime.datetime.now(tz=datetime.timezone.utc).date()).days==0):
                        # Mark that there is data for this notification period (this may be used for later processing)
                        retention_notification_period['activated']=True
                        if mode[0:6]!='silent': print('    Retention notifications activated: '+retention_notification_period['string']+' until courses are removed.')
                        scriptlog+='    Retention notifications activated: '+retention_notification_period['string']+' until courses are removed.\n'
                        if mode[0:6]!='silent': print('      Getting course list...',end='\r')
                        # Get list of courses in this term from Canvas
                        url='https://'+canvas_environment['domains'][canvas_environment['working_environment']]+'/api/v1/accounts/'+str(canvas_environment['account_ids']['working'])+'/courses?enrollment_term_id='+str(term['id'])+'&enrollment_type[]=teacher'
                        canvas_course_list=canvas_get_allpages(url,canvas_environment['url_headers'])
                        # If there was an error getting the course list, display a message, otherwise continue
                        if canvas_course_list.status_code!=200:
                            print(datetime.datetime.now().isoformat()+': Error '+str(canvas_course_list.status_code)+' while retrieving course list from '+url)
                            scriptlog+=datetime.datetime.now().isoformat()+': Error '+str(canvas_course_list.status_code)+' while retrieving course list from '+url+'\n'
                        else:
                            if mode[0:6]!='silent': print('      Getting course list... Retrieved '+str(len(canvas_course_list.data))+' courses.')
                            scriptlog+='      Getting course list... Retrieved '+str(len(canvas_course_list.data))+' courses.\n'
                            # If there are courses in the list
                            if len(canvas_course_list.data)>0:
                                # Get enrollment data for the term via a provisioning report (more efficient than through course API calls)
                                canvas_enrollments_dict=get_canvas_enrollment_provisioning_report(canvas_environment, canvas_environment['account_ids']['working'], term['id'])
`                               # Iterate through each course in the term
                                for course_index, course in enumerate(canvas_course_list.data, start=1):
                                    if mode[0:7]=='verbose': print('      Generating '+retention_notification_period['string']+' course removal notification data... Course '+str(course['id'])+' ('+str(course_index)+'/'+str(len(canvas_course_list))+') ',end='\r')
                                    # Check if there are teachers enrolled in the course to notify about upcoming removal
                                    if (course['id'] in canvas_enrollments_dict.data.keys()) and ('TeacherEnrollment' in canvas_enrollments_dict.data[course['id']].keys()) and ('teacher' in canvas_enrollments_dict.data[course['id']]['TeacherEnrollment'].keys()):
                                        # Iterate through all course teachers
                                        for courseteacher in canvas_enrollments_dict.data[course['id']]['TeacherEnrollment']['teacher']:
                                            # Only notify active/concluded teachers, do not notify deleted/inactive teachers.
                                            if courseteacher['status'] in ['active','concluded']:
                                                # Set up notification date for teacher if it does not already exist
                                                if courseteacher['user_id'] not in retention_notification_data.keys():
                                                    retention_notification_data[courseteacher['user_id']]=[]
                                                    for retention_notifications_index in enumerate(retention_notification_periods):
                                                        retention_notification_data[courseteacher['user_id']].append([])
                                                # Add the course info to the teacher's notification data
                                                if course not in retention_notification_data[courseteacher['user_id']][retention_notification_index]:
                                                    retention_notification_data[courseteacher['user_id']][retention_notification_index].append(course)
                                if mode[0:6]!='silent': print('      Generating '+retention_notification_period['string']+' course removal notification data... ('+str(len(canvas_course_list.data))+'/'+str(len(canvas_course_list.data))+') complete')
                                scriptlog+='      Generating '+retention_notification_period['string']+' course removal notification data... ('+str(len(canvas_course_list.data))+'/'+str(len(canvas_course_list.data))+') complete\n'
                # Delete courses after specified period
                # Check whether the term is older than the deletion period
                if term['end_at']!=None and ((datetime.datetime.fromisoformat(term['end_at'].replace('Z','+00:00')).date()+retention_deletion_period['delta']-datetime.datetime.now(tz=datetime.timezone.utc).date()).days<=0):
                    # Mark that there is data for the deletion period (this may be used for later processing)
                    retention_deletion_period['activated']=True
                    if mode[0:6]!='silent': print('    Retention deletion activated, term end date is at least '+retention_deletion_period['string']+' ago.')
                    scriptlog+='    Retention deletion activated, term end date is at least '+retention_deletion_period['string']+' ago.\n'
                    # Get list of courses in this term from Canvas
                    url='https://'+canvas_environment['domains'][canvas_environment['working_environment']]+'/api/v1/accounts/'+str(canvas_environment['account_ids']['working'])+'/courses?enrollment_term_id='+str(term['id'])
                    canvas_course_list=canvas_get_allpages(url,canvas_environment['url_headers'])
                    # If there was an error getting the course list, display a message, otherwise continue
                    if canvas_course_list.status_code!=200:
                        print(datetime.datetime.now().isoformat()+': Error '+str(canvas_course_list.status_code)+' while retrieving course list from '+url)
                        scriptlog+=datetime.datetime.now().isoformat()+': Error '+str(canvas_course_list.status_code)+' while retrieving course list from '+url+'\n'
                    else:
                        # If there are courses in the list
                        if (len(canvas_course_list.data)>0):
                            print('    Removing courses older than '+retention_deletion_period['string']+'... Retrieved '+str(len(canvas_course_list.data))+' courses.')
                            scriptlog+='    Removing courses older than '+retention_deletion_period['string']+'... Retrieved '+str(len(canvas_course_list.data))+' courses.\n'
                            # Iterate through course list
                            for course_index, course in enumerate(canvas_course_list.data, start=1):
                                if mode[0:6]!='silent': print('      Removing courses... Course '+str(course['id'])+' ('+str(course_index)+'/'+str(len(canvas_course_list.data))+') ',end='\r')
                                # Delete the course
                                url='https://'+canvas_environment['domains'][canvas_environment['working_environment']]+'/api/v1/courses/'+str(course['id'])
                                r=requestswithretry().delete(url,headers=canvas_environment['url_headers'],data={'event':'delete'})
                                # Display a message if error encountered
                                if r.status_code!=200:
                                    print('      Error',r.status_code,'attempting to delete course',course['id'])
                                    scriptlog+='      Error '+str(r.status_code)+' attempting to delete course '+str(course['id'])+'.\n'
                            if mode[0:6]!='silent': print('    Removing courses older than '+retention_deletion_period['string']+'... ('+str(len(canvas_course_list.data))+'/'+str(len(canvas_course_list.data))+') complete')
                            scriptlog+='    Removing courses older than '+retention_deletion_period['string']+'... ('+str(len(canvas_course_list.data))+'/'+str(len(canvas_course_list.data))+') complete\n'
                    # Get full course list for term from root account
                    url='https://'+canvas_environment['domains'][canvas_environment['working_environment']]+'/api/v1/accounts/'+str(canvas_environment['account_ids']['root'])+'/courses?enrollment_term_id='+str(term['id'])
                    canvas_course_list=canvas_get_allpages(url,canvas_environment['url_headers'])
                    # If list was retrieved and it is empty, delete the now unused term from Canvas
                    if canvas_course_list.status_code==200 and len(canvas_course_list.data)==0:
                        url='https://'+canvas_environment['domains'][canvas_environment['working_environment']]+'/api/v1/accounts/'+str(canvas_environment['account_ids']['root'])+'/terms/'+str(term['id'])
                        r=requestswithretry().delete(url,headers=canvas_environment['url_headers'])
                        if r.status_code==200:
                            print('      Term '+str(term['name'])+' ('+str(term['id'])+') successfully deleted.')
                        else:
                            print('      Error',r.status_code,'attempting to delete term',term['name']+' ('+str(term['id'])+').')
                if mode[0:6]!='silent': print('')
        # Send notification emails to teachers
        # Check whether there are any notifications to send
        if len(retention_notification_data.keys())>0:
            # Get user info (names, emails) from Canvas
            url='https://'+canvas_environment['domains'][canvas_environment['working_environment']]+'/api/v1/accounts/'+str(canvas_environment['account_ids']['root'])+'/users?enrollment_type=teacher&include[]=email'
            canvas_teacherusers_list=canvas_get_allpages(url,canvas_environment['url_headers'])
            # If user info was retrieved successfully, nove on, otherwise show the error emssage
            if canvas_teacherusers_list.status_code!=200:
                print(datetime.datetime.now().isoformat()+': Error '+str(canvas_course_list.status_code)+' while retrieving teacher list from '+url)
                scriptlog+=datetime.datetime.now().isoformat()+': Error '+str(canvas_course_list.status_code)+' while retrieving teacher list from '+url+'\n'
            else:
                if mode[0:6]!='silent': print('User Information Retrieved...')
                canvas_teacherusers_dict={}
                # Setup dictionary of the information for easy retieval of info
                for user in canvas_teacherusers_list.data:
                    canvas_teacherusers_dict[user['id']]=user
                # Conect to mail server, display error message if unsuccessful
                try:
                    if email_authrequired:
                        email_server = smtplib.SMTP_SSL(email_smtpservername, email_secureport)
                        email_server.ehlo()
                        try:
                            email_server.login(email_username, email_password)
                        except SMTPAuthenticationError:
                            print('The smtp username and/or password you entered is incorrect')
                    else:
                        email_server = smtplib.SMTP(email_smtpservername, email_secureport)
                        email_server.ehlo()
                        email_server.starttls()
                except:
                    print('An error occurred when connecting to or authenticating with mail server.')
                else:
                    if mode[0:6]!='silent': print('Sending Notification Emails...')
                    scriptlog+='\nSending Notification Emails...\n'
                    # Iterate through users who need to be notified
                    for user_index, user_id in enumerate(retention_notification_data.keys(), start=1):
                        # Make sure user has an email address associated with their account
                        if now ('email' in canvas_teacherusers_dict[user_id].keys()):
                            print('**Alert*** User '+str(user_id)+' does not have an email address, skipping notification email')
                            scriptlog+='**Alert*** User '+str(user_id)+' does not have an email address, skipping notification email\n'
                        else:
                            if mode[0:7]=='verbose': print('Sending Notification Emails... ('+str(user_index)+'/'+str(len(notifications.keys()))+')\r')
                            if debug_email_to_address and debug_email_to_address!='':
                                email_to_address=debug_email_to_address
                            else:
                                email_to_address=canvas_teacherusers_dict[user_id]['email']
                            # Generate notiification messate (plain text and html) for user
                            email_to_name=canvas_teacherusers_dict[user_id]['name']
                            scriptlog+=canvas_teacherusers_dict[user_id]['name']+' ('+canvas_teacherusers_dict[user_id]['email']+')\n'
                            email_subject='Canvas course removal notice'
                            email_body_html='<html><body>'
                            email_body_text='Hello '+canvas_teacherusers_dict[user_id]['name']+',\n\n'
                            email_body_html+='<p>Hello '+canvas_teacherusers_dict[user_id]['name']+',</p>'
                            email_body_text='This automated message is to inform you that the following action(s) will soon be taken.\n\n'
                            email_body_html+='<p>This automated message is to inform you that the following action(s) will soon be taken.</p>'
                            for retention_notification_index in range(0,len(retention_notification_periods)):
                                if len(retention_notification_data[user_id][retention_notification_index])>0:
                                    email_body_text+='The following courses will be removed in '+retention_notification_periods[retention_notification_index]['string']+' days:\n'
                                    email_body_html+='<p>The following courses will be removed in '+retention_notification_periods[retention_notification_index]['string']+' days:</p><ul>'
                                    for course in retention_notification_data[user_id][retention_notification_index]:
                                        email_body_text+='     • '+course['name']+'\n'
                                        email_body_html+='<li><a href=\'https://'+canvas_environment['domains'][canvas_environment['working_environment']]+'/courses/'+str(course['id'])+'\'>'+course['name']+'</a></li>'
                                        scriptlog+='  '+str(retention_notification_periods[retention_notification_index]['string'])+': ('+str(course['id'])+') '+course['name']+'\n'
                                    email_body_text+='\n'
                                    email_body_html+='</ul>'
                            email_body_text+='If you wish to retain Canvas course content and/or student data (names, assignment submissions, grades, etc.), you must do so within the number of days indicated in the above course list(s). If you do not wish to retain any content or student data from these courses, no further action is required.\n'
                            email_body_html+='<p>If you wish to retain Canvas course content and/or student data (names, assignment submissions, grades, etc.), you must do so within the number of days indicated in the above course list(s). If you do not wish to retain any content or student data from these courses, no further action is required.</p>'
                            email_body_text+='     • Save Content from a Canvas Course.  Please note that these methods only save course content.  Methods for saving student data (names, assignment submissions, grades, etc.) are below. \n'
                            email_body_html+='<ul><li>Save Content from a Canvas Course.  Please note that these methods only save course content.  Methods for saving student data (names, assignment submissions, grades, etc.) are below.</li>'
                            email_body_text+='          ○ Export all course content to an imscc zip file\n'
                            email_body_html+='<ul><li><a href=\'https://community.canvaslms.com/t5/Instructor-Guide/How-do-I-export-a-Canvas-course/ta-p/785\'>Export all course content to an imscc zip file</a></li>'
                            email_body_text+='          ○ Share to Canvas commons.\n'
                            email_body_html+='<li><a href=\'https://community.canvaslms.com/t5/Canvas-Commons/How-do-I-share-a-course-to-Commons/ta-p/1793\'>Share to Canvas commons</a>.</li>'
                            email_body_text+='          ○ Bulk download content from the Canvas Files area.\n'
                            email_body_html+='<li><a href=\'https://community.canvaslms.com/t5/Instructor-Guide/How-do-I-download-a-folder-in-ZIP-format-as-an-instructor/ta-p/612\'>Bulk download content from the Canvas Files area</a>.</li>'
                            email_body_text+='          ○ Once data is saved, it may be retained on a local system or approved clous storage system.\n'
                            email_body_html+='<li>Once data is saved, it may be retained on a local system or approved clous storage system.</li></ul>'
                            email_body_text+='     • Save Student Data from a Canvas Course:\n'
                            email_body_html+='<li>Save Student Data from a Canvas Course:</li>'
                            email_body_text+='          ○ Student grades can be saved by exporting the gradebook to a CSV file.\n'
                            email_body_html+='<ul><li>Student grades can be saved by <a href=\'https://community.canvaslms.com/t5/Instructor-Guide/How-do-I-export-grades-in-the-Gradebook/ta-p/809\'>exporting the gradebook to a CSV file</a>.</li>'
                            email_body_text+='          ○ Student submissions can be saved by bulk downloading via the grades area.\n'
                            email_body_html+='<li>Student submissions can be saved by <a href=\'https://community.canvaslms.com/t5/Instructor-Guide/How-do-I-download-all-student-submissions-for-an-assignment-in/ta-p/752\'>bulk downloading via the grades area</a>.</li>'
                            email_body_text+='          ○ Once data is saved, it may be retained on a local system or or approved clous storage system.\n\n'
                            email_body_html+='<li>Once data is saved, it may be retained on a local system or or approved clous storage system.</li></ul></ul>'
                            email_body_text+='If you have any questions, please contact <insert contact info here>.\n'
                            email_body_html+='<p>If you have any questions, please contact <insert contact info here>.</p>'
                            email_body_html+='</body></html>'
                            # Generate the email data (content, sender, recipient
                            email_message = EmailMessage()
                            email_message['Subject']=email_subject
                            email_message['From']=Address(display_name=email_from_name, addr_spec=email_from_address)
                            email_message['To']=Address(display_name=email_to_name, addr_spec=email_to_address)
                            email_message.set_content(email_body_text)
                            email_message.add_alternative(email_body_html.format(make_msgid()[1:-1]), subtype='html')
                            # Send the email
                            email_server.send_message(email_message)
                    if mode[0:6]!='silent': print('Sending Notification Emails... ('+str(len(retention_notification_data.keys()))+'/'+str(len(retention_notification_data.keys()))+') complete')
                    scriptlog+='Sending Notification Emails... ('+str(len(retention_notification_data.keys()))+'/'+str(len(retention_notification_data.keys()))+') complete\n'
                    # close connection to email server
                    email_server.close()

    print('Finished!  Run time: '+str(datetime.datetime.now() - start_time))
    scriptlog+='\nFinished!  Run time:'+str(datetime.datetime.now() - start_time)+'\n'

    # Send script log to specified email if configured
    if log_email_to_address:
        try:
            if email_authrequired:
                email_server = smtplib.SMTP_SSL(email_smtpservername, email_secureport)
                email_server.ehlo()
                try:
                    email_server.login(email_username, email_password)
                except SMTPAuthenticationError:
                    print('The smtp username and/or password you entered is incorrect')
            else:
                email_server = smtplib.SMTP(email_smtpservername, email_secureport)
                email_server.ehlo()
                email_server.starttls()
        except:
            print('An error occurred when trying to send email log.')
        else:
            email_message = EmailMessage()
            email_message['Subject']='Canvas retention script '+canvas_environment['working_environment']+' environment run started at '+start_time.strftime('%Y-%m-%d %I:%M:%S %p')
            email_message['From']=Address(display_name=email_from_name, addr_spec=email_from_address)
            email_message['To']=Address(addr_spec=log_email_to_address)
            email_message.set_content(scriptlog)
            email_server.send_message(email_message)
            email_server.close()
            if mode[0:6]!='silent': print('Log email successfully sent')

    if mode[-10:]!='unattended':
        input("Press Enter to continue...")

if __name__=='__main__':
    main()
